Apache Spark предоставляет две различные методики повышения производительности:
- ==кеширование== с использованием методов `.cache()` и `.persist()`, которые могут _сохранять данные и генеалогию данных^[Генеалогия данных (data lineage) -- происхождение данных. В контексте Spark генеалогия данных представлена ориентированным ациклическим графом]_,
- ==механизм копирования данных в контрольных точках== (checkpointing) с использованием метода `.checkpoint()` для сохранения _только данных без их генеалогии_.

В контексте Spark генеалогия данных -- это и есть ориентированный ациклический граф (DAG).
### Кеширование

Кеширование можно использовать для повышения производительности. При кешировании содержимое кадра данных сохраняется в памяти или на диске или используется совокупность памяти и диска. При кэшировании также сохраняется генеалогия данных.

_Сохранение генеалогии данных_ полезно, только если необходимо восстанавливать набор данных с нуля, а это случается, когда _происходит критический сбой_ в работе одного из узлов кластера.

Spark предоставляет два метода кеширования: `.cache()` и `.persist()`. Они работают почти одинаково, но `.persist()`  позволяет определить применяемый уровень кеширования. Без передачи аргументов `.cache()` является синонимом `.persist(StorageLevel.MEMORY_ONLY)`. В этом случае нет никаких причин использовать один метод вместо другого. 

Доступные _уровни хранения_, определяемые в методе `.persist()`, перечислены ниже:
- `MEMORY_ONLY` -- это уровень по умолчанию. На нем сохраняется RDD, формирующий кадр данных, как десериализованные объекты Java в виртуальной машине JVM. Если RDD не умещается в памяти, то Spark не будет кешировать разделы, а при необходимости выполнит восстановительные вычисления. Пользователь об этом не уведомляется.
- `MEMORY_AND_DISK` -- аналогичен уровню `MEMORY_ONLY`, но когда Spark исчерпывает всю доступную память, он сериализует RDD на диск. Это медленее, так как диск более медленное устройство, но производительность будет различной в зависимости от класса хранилища на узле (например, NVM-накопители по сравнению с механическими накопителями).
- `MEMORY_ONLY_SER` -- аналогичен уровню `MEMORY_ONLY`, но объекты Java _сериализуются_. Это требует _меньшего пространства памяти_, но подготовка потребляет _больше процессорного времени_.
- `MEMORY_AND_DISK_SER` -- аналогичен уровню `MEMORY_AND_DISK`, но с сериализацией.
- `DISK_ONLY` -- на диск сохраняются разделы RDD, формирующие кадр данных.
- `OFF_HEAP` -- поведение аналогично уровню `MEMORY_ONLY_SER`, но здесь используется память вне кучи. Память вне кучи требует активизации.

Уровни `MEMORY_AND_DISK_2`, `MEMORY_AND_DISK_SER_2`, `MEMORY_ONLY_2` и `MEMORY_ONLY_SER_2` равнозначны уровням без суффикса `_2`, но добавляют _репликацию_ каждого раздела на двух узлах кластера. Эти уровни следует устанавливать, если необходима репликация данных с повышенной доступностью.

Можно использовать метод `.unpersist()` для _освобождения кеша_, а также метод `storageLevel()` для запроса текущего уровня кеширования кадра данных. Метод `.unpersist()` будет очищать кеш вне зависимости от того, создан ли кеш методом `.cache()` или `.persist()`. Кеш очищается, когда больше не требуется использование соответствующего кадра данных, и можно освободить память для обработки других наборов данных.

Если кадр данных не кеширован / не сохраняется, то метод `storageLevel()` возвращает значение `StorageLevel.NONE`. Если вы не освободили память, вручную, то она будет освобождена при завершении текущего сеанса, но в текущем сеансе эта память остается недоступной для других данных или для выполнения обработки.