Тезисно:
- метод `.over()` превращает обычную функцию в _оконную_,
- окно вида `Window.partitionBy("...")` работает как обычный "групировщик", который каждый элементы группы замещает результатом агрегации (похоже на то, как себя ведет метод `.transform()` в Pandas),
- окно вида `Window.partitionBy("...").orderBy("...").rowsBetween(-n, n)` позволяет вычислять агрегаты на _скользящем окне_ шириной `2 * n + 1` (включается текущая строка с индексом `0`),
- окно вида `Window.partitionBy("...").orderBy("...").rangeBetween(Window.unboundedPreceding, 0)` (то есть учитываются текущая строка и все предыдущие) позволяет строить агрегаты на _расширяющемся окне_.

Если не задавать порядок сортировки в `Window.partitionBy("...")`, то эта конструкция будет работать как простой группировщик. То есть другими словами по имени атрибута, указанного в `Window.partitionBy("...")` будет выполнена группировка. Если вычисляются какие-то агрегаты по группам, то каждый элемент группы будет заменен результатом агрегации по этой группе. К примеру, если используется простая форма партиционирования (без упорядочивания в группе), а затем вычисляется среднее по группе, то каждый элемент группы будет заменен средним по группе. 
```python
df.select(
	"id", "x", "color",
	F.mean("x").over(Window.partitionBy("color")).alias("mean_x")
).show()
```

В Pandas эту задачу можно было бы решать так
```python
df.loc[:, "mean_x"] = df.groupby("color")[["x"]].transform("mean")
```

То есть по сути выполняется простая группировка по `color` как в
```python
df.groupBy("color").agg(F.mean("x").alias("mean_x")).show()
```
а затем каждый элемент своей группы заменяется средним этой группы.

Можно записать еще так
```python
# Работает как простая группировка по `color`, потому что не указан порядок сортировки (orderBy)
w_ = Window.partitionBy("color")

df.select("id", "x", "y") \
    .withColumn("min_x", F.mean("x").over(w_)) \
    .withColumn("mean_x", F.mean("x").over(w_)) \
    .withColumn("sum_x", F.sum("x").over(w_)).show()

# output
+---+---+-----+-----+-----------------+-----+
| id|  x|color|min_x|           mean_x|max_x|
+---+---+-----+-----+-----------------+-----+
|  7| 18| blue|   18|            493.0|  968|
|  9|968| blue|   18|            493.0|  968|
|  0|987|green|  189|            686.8|  987|
|  2|189|green|  189|            686.8|  987|
|  4|586|green|  189|            686.8|  987|
|  5|973|green|  189|            686.8|  987|
|  6|699|green|  189|            686.8|  987|
|  1|596|  red|  238|406.3333333333333|  596|
|  3|238|  red|  238|406.3333333333333|  596|
|  8|385|  red|  238|406.3333333333333|  596|
+---+---+-----+-----+-----------------+-----+
```

Если теперь добавить сортировку по группе в `Window.partitionBy("...").orderBy("...")`, то можно будет воспользоваться функциями `F.row_number()`, `F.rank()`, `F.dense_rank()`, `F.percent_rank()` и `F.ntile(n)`.
```python
w_ = Window.partitionBy("color").orderBy("x")

df.select("id", "x", "color") \
    .withColumn("rank_y", F.rank().over(w_)) \
    .withColumn("row_number", F.row_number().over(w_)) \
    .withColumn("dense_rank_y", F.dense_rank().over(w_)) \
    .withColumn("percent_rank_y", F.percent_rank().over(w_)) \
    .withColumn("ntile", F.ntile(2).over(w_)).show()
# output
+---+---+-----+------+------------+------------+--------------+-------+
| id|  x|color|rank_y|row_number_y|dense_rank_y|percent_rank_y|ntile_y|
+---+---+-----+------+------------+------------+--------------+-------+
|  7| 18| blue|     1|           1|           1|           0.0|      1|
|  9|968| blue|     2|           2|           2|           1.0|      2|
|  2|189|green|     1|           1|           1|           0.0|      1|
|  4|586|green|     2|           2|           2|          0.25|      1|
|  6|699|green|     3|           3|           3|           0.5|      1|
|  5|973|green|     4|           4|           4|          0.75|      2|
|  0|987|green|     5|           5|           5|           1.0|      2|
|  3|238|  red|     1|           1|           1|           0.0|      1|
|  8|385|  red|     2|           2|           2|           0.5|      1|
|  1|596|  red|     3|           3|           3|           1.0|      2|
+---+---+-----+------+------------+------------+--------------+-------+
```

Если нужно создать лаговые признаки с различными смещениями, то можно воспользоваться функциями `.lag()` или `.lead()`
```python
# Предполагается, что есть константный атрибут `group`
w_ = Window.partitionBy("group").orderBy("id")

df.withColumn("lag_x_1", F.lag("x").over(w_)) \
    .withColumn("lag_x_2", F.lag("x").over(w_)).show()
```

Обязательно нужно указывать `.over()`, так как `.lag()` и `.lead()` это тоже оконные функции.

Часто бывает полезно строить столбцы, содержащие результаты скользящего среднего, кумулятивной суммы и пр. Для этого требуется к объекту окна добавить еще один элемент. Можно использовать `rangeBetween` или `rowsBetween`.

Текущая строка считаетя нулевой. Последующие строки нумеруются положительными числами, а предшествующие -- отрицательными.

"Все предыдущие строки" можно задать как `Window.unboundedPreceding`, а "все последующие" -- как `Window.unboundedFolowing`.

Для примера посчитает скользящее среднее с шириной окна в 3 элемента -- `.rowsBetween(-1, 1)`. Эта запись означает, что мы "смотрим" на текущую строку, одну предыдущую (`-1`) и еще одну следующую (`1`).
```python
# Скользящее окно
w_ = Window.partitionBy("color").orderBy("x").rowsBetween(-1, 1)

df.select("id", "x", "color") \
    .withColumn("rolling_sum", F.sum("x").over(w_)).show()
# output
+---+---+-----+-----------+
| id|  x|color|rolling_sum|
+---+---+-----+-----------+
|  7| 18| blue|        986|  # 18 + 968 = 986
|  9|968| blue|        986|  # 968 + 18 = 986
|  2|189|green|        775|  # 189 + 586 = 775
|  4|586|green|       1474|  # 586 + 189 + 699 = 1474
|  6|699|green|       2258|  # 699 + 586 + 973 = 2258
|  5|973|green|       2659|  # ...
|  0|987|green|       1960|
|  3|238|  red|        623|
|  8|385|  red|       1219|
|  1|596|  red|        981|
+---+---+-----+-----------+
```

Рассмотрим подробнее как вычисляется скользящая сумма для группы `green`. Первое значение в группе `green` это `189`. То есть значение `189` это текущая строка. Предыдущего значения у нас еще нет, а следующее значение -- `586`, поэтому текущему значению `189` отвечает скользящая сумма `189 + 586 = 775`. Следующим текущим значением будет `586`. Теперь у нас есть предыдущее значение `189` и следующее `699`, поэтому текущему значению `586` отвечает скользящая сумма `586 + 189 + 699 = 1474`. И т.д.

То есть запись `Window.partitionBy("color").orderBy("x").rowsBetween(-n, n)` позволяет вычислять агрегаты на _скользящем окне_ шириной в $2 n + 1$ элемента.

Чтобы вычислять агрегаты на _расширяющемся окне_, следует использовать такую конструкцию
```python
# Расширяющееся окно
Window.partitionBy("color").orderBy("x").rangeBetween(
	Window.unboundedPreceding,  # все предыдущие строки группы
	0  # текущая строка
)
```

Предыдущий пример, но с расширяющимся окном по группе
```python
df.select("id", "x", "color") \
    .withColumn("cum_sum", F.sum("x").over(w_)).show()
# output
+---+---+-----+-------+
| id|  x|color|cum_sum|
+---+---+-----+-------+
|  7| 18| blue|     18|  # 18
|  9|968| blue|    986|  # 18 + 968 = 986
|  2|189|green|    189|  # 189 
|  4|586|green|    775|  # 586 + 189 = 775
|  6|699|green|   1474|  # 699 + 189 + 586 = 1474
|  5|973|green|   2447|  # ...
|  0|987|green|   3434|
|  3|238|  red|    238|
|  8|385|  red|    623|
|  1|596|  red|   1219|
+---+---+-----+-------+
```